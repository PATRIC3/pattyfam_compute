
#
# Given a set of family directories, and the corresponding kmer data directory,
# compute a merge of the families.
#
# We merge based on function. We assign function numbers based on the function.index
# file in the kmer data directory.
#
# We utilize the per-function (function index from associated kmers) fasta files of
# protein sequences as generated by pf-compute-local-families.
#
# The ids given to the proteins in the fasta files are of the form
# genus-name:genus-id:fam-id:peg so that join decisions later on can be made strictly on
# the results from the clustering on these fasta files.
#
# We use the representatives as computed by the local family code.
#
# Given the set of fasta files, we use the kmer distance clustering algorithm to
# compute suggested family merges.
#

use DBI;
use strict;
use Data::Dumper;
use Getopt::Long::Descriptive;
use IO::Handle;
use File::Path 'make_path';
use File::Copy;
use File::Slurp;
use Statistics::Descriptive;
use File::Basename;
use gjoseqlib;
use Algorithm::Numerical::Shuffle qw /shuffle/;
use POSIX ':sys_wait_h';
use IPC::Run;
use LPTScheduler;
use List::Util qw(max min reduce);

my($opt, $usage) = describe_options("%c %o kmer-dir merge-dir famdir famdir [famdir ...]",
				    ['subsystem=s@', "Merge roles that occur in this subsystem only", { default => [] }],
				    ["parallel|p=i", "Number of jobs to run in parallel", { default => 1 }],
				    ["serial", "Force serial execution"],
				    ["kser=s" => "Path to kser executable", { default => "/home/olson/P3/close_kmers/kser" }],
				    ["log|l=s", "Trace logfile"],
				    ["dist-dir=s", "Directory into which distances are written"],
				    ["help|h", "Show this help message"]);

print($usage->text), exit if $opt->help;
die($usage->text) if @ARGV < 4;

if ($opt->log)
{
    open(LOG, ">>", $opt->log) or die "Cannot open logfile " . $opt->log . ": $!";
    LOG->autoflush(1);
}
else
{
    open(LOG, ">", "/dev/null");
}

my $kmer_dir = shift;
my $merge_dir = shift;
my @fam_dirs = @ARGV;

my %desired_roles;
my($function_to_index, $index_to_function) = read_function_index($kmer_dir);

for my $subsystem (@{$opt->subsystem})
{
    my $ss_dir = "/vol/core-seed/FIGdisk/FIG/Data/Subsystems/$subsystem";
    open(S, "<",  "$ss_dir/spreadsheet") or die "Cannot open subsystem spreadsheet $ss_dir/spreadsheet: $!";
    
    while (<S>)
    {
	chomp;
	last if m,^//,;
	my($abbr, $role) = split(/\t/);
	$desired_roles{$role} = $abbr;
	if (!defined($function_to_index->{$role}))
	{
	    warn "Role $role not present in function index\n";
	}
	
    }
    close(S);
}

my $tmpdir = "$merge_dir/tmp";
make_path($tmpdir);

#remove? my $fa_dir = "$merge_dir/family.fasta";

my $dist_dir = $opt->dist_dir;
if (!$dist_dir)
{
    $dist_dir = "$merge_dir/family.dist";
}

make_path($dist_dir);

# remove? my $map_file = "$merge_dir/peg.map";

#
# Given the set of fasta data we've collected, feed the LPT scheduler
# with the functions weighted by the size of the function fasta file in a large genus.
#
# Use the size of the local.family.members file as a proxy for size, and pull per-function
# fasta sizes from there. If a function is missing, assign weight of 1000.
#

my(%fn_size, %fn_list);
for my $fd (@fam_dirs)
{
    opendir(D, "$fd/fasta_by_function") or die "Cannot opendir $fd/fasta_by_function: $!";
    for my $fn (readdir(D))
    {
	next unless $fn =~ /^\d+$/;
	my $fnfile = "$fd/fasta_by_function/$fn";
	
	$fn_size{$fn} += -s $fnfile;
	push(@{$fn_list{$fn}}, $fnfile);
    }
    closedir(D);
}

my $sched = LPTScheduler->new($opt->parallel);

$sched->add_work([$_, $fn_list{$_}], $fn_size{$_}) foreach keys %fn_size;

$sched->run(sub {}, \&do_work);

sub do_work
{
    my($glob, $item) = @_;
    my($fn, $fa_list) = @$item;
    print "$$ $fn: @$fa_list\n";

    my($kser_pid, $kser_port) = start_kser($tmpdir, $kmer_dir);
    
    my $add_url = "http://localhost:$kser_port/add";
    my $matrix_url = "http://localhost:$kser_port/matrix";
    print "curl to $add_url\n";
    
    $SIG{__DIE__} = sub {
	kill 1, $kser_pid;
    };

    for my $fa_file (@$fa_list)
    {
	print "Add $fa_file\n";
	my $calls_out = "/dev/null"; # don't need this data

	my $rc = system("curl", "-s", "-S", "-o", $calls_out, "-H", "kmer-options: -a -d 1", "--data-binary", "\@$fa_file", $add_url);
	if ($rc != 0)
	{
	    die "Error loading fasta data\n";
	}
	print "Done\n";
    }

    my $pipe = IO::Handle->new();
    my @cmd = ("kmer_guts_net", "-u", $matrix_url, "-d", 1, "-a");
    my $h = IPC::Run::start(\@cmd,
			    '<pipe', $pipe,
			    '>', "$dist_dir/$fn");
    $h or die "Could not start @cmd: $?\n";
    for my $fa_file (@$fa_list)
    {
	print "Send $fa_file to pipe\n";
	copy($fa_file, $pipe);
    }
    close($pipe);
    my $ok = $h->finish();
    if (!$ok)
    {
	die "Failed @cmd < [fa_files] > $dist_dir/$fn\n";
    }
    
    print "Killing $kser_pid\n";
    kill 1, $kser_pid;
    print "Waiting on $kser_pid\n";
    waitpid $kser_pid, 0;
    print "Done waiting\n";
}

sub read_function_index
{
    my($dir) = @_;

    my $idx = {};
    my $from_id = [];

    open(F, "<", "$dir/function.index") or die "Cannot open $dir/function.index:$ !";
    while (<F>)
    {
	chomp;
	my($i, $fun) = split(/\t/);
	$idx->{$fun} = $i;
	$from_id->[$i] = $fun;
    }
    close(F);
    
    return($idx, $from_id);
}

sub start_servers
{
    my($tmpdir, $dataD) = @_;

    my($kser_pid, $kser_port) = start_kser($tmpdir, $dataD);
    
    return ($kser_pid, $kser_port);
}

sub start_kser
{
    my($tmpdir, $dataD) = @_;
    
    #
    # Start the stateful kmer server
    #
    
    my $kser_port_file = "$tmpdir/kser_port.$$";
    my @kser_cmd = ($opt->{kser},
		    "--listen-port-file", $kser_port_file, 0, $dataD);
    unlink($kser_port_file);
    
    my $kser_pid = fork;
    if (!defined($kser_pid))
    {
	die "fork failed: $!";
    }
    if ($kser_pid == 0)
    {
	print "Starting kser_cmd in $$: @kser_cmd\n";
	exec(@kser_cmd);
	die "Kser did not start $?: @kser_cmd\n";
    }
    
    my $kser_port;
    while (1)
    {
	my $kid = waitpid($kser_pid, WNOHANG);
	if ($kid)
	{
	    die "kser server did not start\n";
	}
	if (-s $kser_port_file)
	{
	    $kser_port = read_file($kser_port_file);
	    chomp $kser_port;
	    if ($kser_port !~ /^\d+$/)
	    {
		kill(1, $kser_pid);
		kill(9, $kser_pid);
		die "Invalid kser port '$kser_port'\n";
	    }
	    last;
	}
	sleep(0.1);
    }
    
    print "Kser running pid $kser_pid on port $kser_port\n";
    
    return ($kser_pid, $kser_port);
}





